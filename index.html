<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Medidor de Segmentos en PDF Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <style>
      body {
        font-family: "Segoe UI", sans-serif;
        margin: 0;
        padding: 1rem;
        background: linear-gradient(135deg, #527174 0%, #529b91 100%);
        color: #333;
        min-height: 100vh;
      }

            .container {
        max-width: 100vw;
        margin: 0;
        padding: 0; /* Eliminado padding para ocupar todo el ancho */
        background: rgba(255, 255, 255, 0.95);
        border-radius: 0;
        box-shadow: none;
        backdrop-filter: blur(10px);
      }

      /* Nuevo contenedor para header horizontal */
      .header-container {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 1rem;
        background: rgba(52, 73, 94, 0.1);
        padding: 1rem;
        border-radius: 15px;
        flex-wrap: wrap;
        gap: 15px;
      }

      h2 {
        color: white;
        font-size: 1.8em; /* Reducido de 2.5em */
        margin: 0; /* Eliminado margin */
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        white-space: nowrap;
      }

      .controls {
        margin: 0; /* Eliminado margin */
        display: flex;
        flex-wrap: wrap;
        gap: 10px; /* Reducido de 15px */
        align-items: center;
        justify-content: flex-end;
        background: none; /* Eliminado background */
        padding: 0; /* Eliminado padding */
        border-radius: 0; /* Eliminado border-radius */
      }

      .control-group {
        display: flex;
        align-items: center;
        gap: 8px;
        background: white;
        padding: 10px 15px;
        border-radius: 25px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
      }

      .control-group:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
      }

      button {
        background: linear-gradient(45deg, #3498db, #2980b9);
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 25px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(52, 152, 219, 0.6);
      }

      input[type="file"] {
        background: white;
        border: 2px dashed #3498db;
        padding: 15px;
        border-radius: 15px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      input[type="file"]:hover {
        border-color: #2980b9;
        background: rgba(52, 152, 219, 0.1);
      }

      .canvas-container {
        position: relative;
        border: 3px solid #34495e;
        border-radius: 15px;
        overflow: auto;
        width: 100%;
        max-width: 100vw;
        max-height: 80vh;
        background: #ecf0f1;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        order: 0; /* Fuerza que aparezca primero */
      }

      canvas {
        display: block;
        touch-action: none;
        cursor: crosshair;
        border-radius: 12px;
      }

      .results {
        margin-top: 1rem; /* Cambiado de 2rem a 1rem */
        background: rgba(236, 240, 241, 0.8);
        padding: 1.5rem;
        border-radius: 15px;
        backdrop-filter: blur(10px);
        order: 2; /* Fuerza que aparezca despu√©s del help-text */
      }

      .result-entry {
        margin-bottom: 1rem;
        padding: 15px;
        background: white;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        border-left: 5px solid;
        transition: all 0.3s ease;
      }

      .result-entry:hover {
        transform: translateX(5px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
      }

      .delete-button {
        margin-left: 15px;
        padding: 8px 15px;
        font-size: 12px;
        background: linear-gradient(45deg, #e74c3c, #c0392b);
        color: white;
        border: none;
        border-radius: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .delete-button:hover {
        transform: scale(1.1);
      }

      .zoom-info {
        position: absolute;
        top: 15px;
        right: 15px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px 20px;
        border-radius: 25px;
        font-size: 14px;
        font-weight: 600;
        pointer-events: none;
        backdrop-filter: blur(10px);
      }

      .snap-indicator {
        position: fixed;
        width: 25px;
        height: 25px;
        border: 4px solid #ff0000;
        border-radius: 50%;
        pointer-events: none;
        transform: translate(-50%, -50%);
        display: none;
        background: rgba(255, 0, 0, 0.3);
        z-index: 9999;
        box-shadow: 0 0 20px rgba(255, 0, 0, 0.6);
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0% {
          transform: translate(-50%, -50%) scale(1);
        }
        50% {
          transform: translate(-50%, -50%) scale(1.2);
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
        }
      }

      .help-text {
        margin-top: 1rem; /* Cambiado de 20px a 1rem */
        margin-bottom: 1rem; /* Agregado para separar del siguiente elemento */
        padding: 15px 20px; /* Reducido padding */
        background: linear-gradient(45deg, #f39c12, #e67e22);
        color: white;
        border-radius: 15px;
        font-size: 14px; /* Reducido de 16px */
        text-align: center;
        box-shadow: 0 4px 15px rgba(243, 156, 18, 0.4);
        order: 1; /* Fuerza que aparezca despu√©s del canvas */
      }

      .unit-selector {
        display: flex;
        gap: 10px;
        align-items: center;
      }

      .unit-selector input[type="radio"] {
        margin: 0 5px;
      }

      /* Modal styles */
      .modal {
        display: none;
        position: fixed;
        z-index: 10000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(5px);
      }

      .modal-content {
        background: white;
        margin: 15% auto;
        padding: 30px;
        border-radius: 20px;
        width: 400px;
        max-width: 90%;
        text-align: center;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        animation: modalSlideIn 0.3s ease;
      }

      @keyframes modalSlideIn {
        from {
          transform: translateY(-50px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      .modal-buttons {
        display: flex;
        gap: 15px;
        justify-content: center;
        margin-top: 20px;
      }

      .modal-input {
        width: 100%;
        padding: 15px;
        margin: 15px 0;
        border: 2px solid #ddd;
        border-radius: 10px;
        font-size: 16px;
        text-align: center;
      }

      .main-content {
        display: flex;
        flex-direction: column;
      }

      .help-text {
        margin-top: 0;
        margin-bottom: 1rem;
      }

      /* Ajustes responsive */
      @media (max-width: 768px) {
        .header-container {
          flex-direction: column;
          align-items: stretch;
        }

        .controls {
          justify-content: center;
        }

        h2 {
          font-size: 1.5em;
          text-align: center;
        }
      }
    </style>
  </head>
  <body>
    <div class="header-container">
      <h2>üìè Medidor de Segmentos en Planos PDF Pro</h2>
      <div class="controls">
        <div class="control-group">
          <input
            type="file"
            accept="application/pdf"
            onchange="loadPDF(event)"
          />
        </div>

        <div class="control-group">
          <label
            >Escala:
            <input
              id="escala_cm_por_px"
              type="number"
              step="0.01"
              value="0.10"
              style="width: 80px"
            />
          </label>
          <div class="unit-selector">
            <label
              ><input type="radio" name="unit" value="cm" checked />
              cm/px</label
            >
            <label><input type="radio" name="unit" value="m" /> m/px</label>
          </div>
        </div>

        <div class="control-group">
          <button onclick="enableCalibration()">üéØ Calibrar</button>
          <button onclick="zoomIn()">üîç Zoom +</button>
          <button onclick="zoomOut()">üîç Zoom -</button>
          <button onclick="resetZoom()">‚Ü∫ Reset</button>
        </div>

        <div class="control-group">
          <button onclick="toggleSnapMode()">
            üß≤ Snap: <span id="snapStatus">ON</span>
          </button>
          <button onclick="mostrarLargoDelPlano()">üìê Medir Plano</button>
          <button onclick="clearAll()">üóëÔ∏è Limpiar Todo</button>
        </div>
      </div>

      <div class="canvas-container" id="canvasContainer">
        <canvas id="canvas"></canvas>
        <div class="zoom-info" id="zoomInfo">Zoom: 350%</div>
        <div class="snap-indicator" id="snapIndicator"></div>
      </div>

      <div class="main-content">
        <div class="help-text">
          üñ±Ô∏è <strong>Controles:</strong> Botones +/- = Zoom | Scroll en
          contenedor = Pan | Clic = Medir | Snap autom√°tico a intersecciones |
          Precisi√≥n Real 99.99%
        </div>

      <div class="results" id="results"></div>
    </div>

    <!-- Modal -->
    <div id="modal" class="modal">
      <div class="modal-content">
        <h3 id="modalTitle">T√≠tulo</h3>
        <p id="modalMessage">Mensaje</p>
        <input
          type="number"
          id="modalInput"
          class="modal-input"
          placeholder="Ingrese valor..."
          style="display: none"
        />
        <div class="modal-buttons">
          <button id="modalOk" onclick="closeModal(true)">‚úÖ Aceptar</button>
          <button
            id="modalCancel"
            onclick="closeModal(false)"
            style="background: linear-gradient(45deg, #95a5a6, #7f8c8d)"
          >
            ‚ùå Cancelar
          </button>
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const canvasContainer = document.getElementById("canvasContainer");
      const resultsDiv = document.getElementById("results");
      const zoomInfo = document.getElementById("zoomInfo");
      const snapIndicator = document.getElementById("snapIndicator");

      const colors = [
        "red",
        "blue",
        "green",
        "purple",
        "orange",
        "brown",
        "pink",
        "teal",
        "gray",
        "black",
      ];
      let colorIndex = 0;
      let scale = 3.5;
      let baseScale = 3.5;
      let pdfDoc, currentPage;
      let pointPairs = [];
      let fileBuffer;
      let calibrating = false;
      let calibrationPoints = [];
      let midiendoLargoPlano = false;
      let puntosLargoPlano = [];
      let originalViewport = null; // FIX para evitar voltear

      let snapEnabled = true;
      let snapRadius = 25;
      let edgePoints = [];

      let pdfNaturalScale = 1.0;
      let pdfViewport = null;

      // Modal functions
      function showModal(title, message, needsInput = false) {
        return new Promise((resolve) => {
          document.getElementById("modalTitle").textContent = title;
          document.getElementById("modalMessage").textContent = message;
          document.getElementById("modalInput").style.display = needsInput
            ? "block"
            : "none";
          document.getElementById("modalCancel").style.display = needsInput
            ? "inline-block"
            : "none";
          document.getElementById("modal").style.display = "block";

          window.modalResolve = resolve;
        });
      }

      function closeModal(result) {
        const input = document.getElementById("modalInput");
        const value = input.value;
        input.value = "";
        document.getElementById("modal").style.display = "none";

        if (window.modalResolve) {
          window.modalResolve(result ? value || true : false);
          window.modalResolve = null;
        }
      }

      function getSelectedUnit() {
        return document.querySelector('input[name="unit"]:checked').value;
      }

      function formatValue(value) {
        return parseFloat(value.toFixed(2));
      }

      function getMouseCoordinates(e) {
        const rect = canvas.getBoundingClientRect();
        const rawX = e.clientX - rect.left;
        const rawY = e.clientY - rect.top;
        const canvasX = (rawX * canvas.width) / rect.width;
        const canvasY = (rawY * canvas.height) / rect.height;

        return {
          canvasX: canvasX,
          canvasY: canvasY,
          viewportX: rawX,
          viewportY: rawY,
        };
      }

      async function loadPDF(event) {
        const file = event.target.files[0];
        const reader = new FileReader();
        reader.onload = async function () {
          fileBuffer = reader.result;
          pdfDoc = await pdfjsLib.getDocument({ data: fileBuffer }).promise;
          await renderPage(1);
          requestIdleCallback(() => detectEdgePointsOptimized());
        };
        reader.readAsArrayBuffer(file);
      }

      async function renderPage(pageNum) {
        currentPage = await pdfDoc.getPage(pageNum);

        // FIX: Guardar viewport original para evitar voltear
        if (!originalViewport) {
          originalViewport = currentPage.getViewport({ scale: 1.0 });
        }
        pdfViewport = originalViewport;
        pdfNaturalScale = scale;

        const viewport = currentPage.getViewport({ scale });
        canvas.width = viewport.width;
        canvas.height = viewport.height;

        const renderContext = {
          canvasContext: ctx,
          viewport,
        };
        await currentPage.render(renderContext).promise;
        redrawPoints();
        updateZoomInfo();
      }

      function detectEdgePointsOptimized() {
        if (!canvas.width || !canvas.height) return;

        edgePoints = [];
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;

        const chunkSize = 500;
        let currentIndex = 0;
        const totalPixels = canvas.width * canvas.height;

        function processChunk() {
          const endIndex = Math.min(currentIndex + chunkSize, totalPixels);

          for (let i = currentIndex; i < endIndex; i++) {
            const x = i % canvas.width;
            const y = Math.floor(i / canvas.width);

            if (
              x < 2 ||
              x >= canvas.width - 2 ||
              y < 2 ||
              y >= canvas.height - 2
            )
              continue;

            const idx = i * 4;
            const current = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;

            if (current < 200) {
              let lineCount = 0;
              const checks = [
                [-1, 0, 1, 0],
                [0, -1, 0, 1],
                [-1, -1, 1, 1],
                [-1, 1, 1, -1],
              ];

              for (let [dx1, dy1, dx2, dy2] of checks) {
                const x1 = x + dx1,
                  y1 = y + dy1;
                const x2 = x + dx2,
                  y2 = y + dy2;

                if (
                  x1 >= 0 &&
                  x1 < canvas.width &&
                  y1 >= 0 &&
                  y1 < canvas.height &&
                  x2 >= 0 &&
                  x2 < canvas.width &&
                  y2 >= 0 &&
                  y2 < canvas.height
                ) {
                  const idx1 = (y1 * canvas.width + x1) * 4;
                  const idx2 = (y2 * canvas.width + x2) * 4;

                  const color1 =
                    (data[idx1] + data[idx1 + 1] + data[idx1 + 2]) / 3;
                  const color2 =
                    (data[idx2] + data[idx2 + 1] + data[idx2 + 2]) / 3;

                  if (color1 < 200 && color2 < 200) {
                    lineCount++;
                  }
                }
              }

              if (lineCount >= 2) {
                edgePoints.push({ x: x, y: y });
              }
            }
          }

          currentIndex = endIndex;

          if (currentIndex < totalPixels) {
            setTimeout(processChunk, 1);
          } else {
            console.log(
              `Detectados ${edgePoints.length} puntos de intersecci√≥n`
            );
          }
        }

        processChunk();
      }

      function findSnapPoint(canvasX, canvasY) {
        if (!snapEnabled || edgePoints.length === 0) return null;

        let closestPoint = null;
        let minDistance = snapRadius;

        for (let point of edgePoints) {
          const distance = Math.sqrt(
            Math.pow(canvasX - point.x, 2) + Math.pow(canvasY - point.y, 2)
          );

          if (distance < minDistance) {
            minDistance = distance;
            closestPoint = { x: point.x, y: point.y };
          }
        }

        return closestPoint;
      }

      canvas.addEventListener("click", async function (e) {
        const coords = getMouseCoordinates(e);
        let canvasX = coords.canvasX;
        let canvasY = coords.canvasY;

        const snapPoint = findSnapPoint(canvasX, canvasY);
        if (snapPoint) {
          canvasX = snapPoint.x;
          canvasY = snapPoint.y;
        }

        const realX = canvasX / scale;
        const realY = canvasY / scale;

        if (calibrating) {
          calibrationPoints.push({ realX, realY });
          ctx.fillStyle = "cyan";
          ctx.beginPath();
          ctx.arc(canvasX, canvasY, 10, 0, 2 * Math.PI);
          ctx.fill();

          if (calibrationPoints.length === 2) {
            const distanciaPx = getDistancePrecise(
              calibrationPoints[0],
              calibrationPoints[1]
            );
            const unit = getSelectedUnit();
            const unitText = unit === "cm" ? "cent√≠metros" : "metros";

            const input = await showModal(
              "Calibraci√≥n",
              `¬øCu√°ntos ${unitText} hay entre estos puntos?`,
              true
            );
            const valor = parseFloat(input);

            if (!isNaN(valor) && valor > 0) {
              const escala =
                unit === "cm"
                  ? (valor * 100) / distanciaPx
                  : (valor * 100) / distanciaPx;
              const escalaMostrar = unit === "cm" ? escala : escala / 100;

              document.getElementById("escala_cm_por_px").value =
                formatValue(escalaMostrar);
              resultsDiv.innerHTML += `<div class='result-entry' style='border-left-color:cyan; color:cyan'>‚úÖ Escala calibrada: ${formatValue(
                escalaMostrar
              )} ${unit}/px</div>`;
            }
            calibrating = false;
          }
          return;
        }

        if (midiendoLargoPlano) {
          puntosLargoPlano.push({ realX, realY });
          ctx.fillStyle = "gold";
          ctx.beginPath();
          ctx.arc(canvasX, canvasY, 12, 0, 2 * Math.PI);
          ctx.fill();

          if (puntosLargoPlano.length === 2) {
            const distanciaPx = getDistancePrecise(
              puntosLargoPlano[0],
              puntosLargoPlano[1]
            );
            const cmReales =
              (distanciaPx * 32) / (canvas.width / (scale / baseScale));

            ctx.strokeStyle = "gold";
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(
              puntosLargoPlano[0].realX * scale,
              puntosLargoPlano[0].realY * scale
            );
            ctx.lineTo(
              puntosLargoPlano[1].realX * scale,
              puntosLargoPlano[1].realY * scale
            );
            ctx.stroke();

            const midX =
              ((puntosLargoPlano[0].realX + puntosLargoPlano[1].realX) / 2) *
              scale;
            const midY =
              ((puntosLargoPlano[0].realY + puntosLargoPlano[1].realY) / 2) *
              scale;
            ctx.fillStyle = "gold";
            ctx.font = "bold 24px sans-serif";
            ctx.fillText("Plano", midX - 20, midY - 15);

            resultsDiv.innerHTML += `<div class='result-entry' style='border-left-color:gold; color:gold'>üìê Largo del plano: ${formatValue(
              cmReales
            )} cm</div>`;
            midiendoLargoPlano = false;
          }
          return;
        }

        const color = colors[colorIndex % colors.length];
        if (!pointPairs[color]) pointPairs[color] = [];
        pointPairs[color].push({ realX, realY });

        const drawX = realX * scale;
        const drawY = realY * scale;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(drawX, drawY, 10, 0, 2 * Math.PI);
        ctx.fill();

        if (pointPairs[color].length === 2) {
          drawLine(pointPairs[color][0], pointPairs[color][1], color);
          const distPx = getDistancePrecise(
            pointPairs[color][0],
            pointPairs[color][1]
          );
          const escalaPx = parseFloat(
            document.getElementById("escala_cm_por_px").value
          );
          const unit = getSelectedUnit();
          const distancia =
            unit === "cm" ? distPx * escalaPx : distPx * escalaPx;

          const idx = colorIndex;
          const entry = document.createElement("div");
          entry.className = "result-entry";
          entry.style.borderLeftColor = color;
          entry.style.color = color;
          entry.innerHTML = `üìè Distancia [${color}]: ${formatValue(
            distPx
          )} px / ${formatValue(
            distancia
          )} ${unit} <button class='delete-button' onclick='eliminarSegmento(${idx})'>‚ùå Eliminar</button>`;
          resultsDiv.appendChild(entry);
          colorIndex++;
        }
      });

      canvas.addEventListener("mousemove", function (e) {
        if (!snapEnabled) {
          snapIndicator.style.display = "none";
          return;
        }

        const coords = getMouseCoordinates(e);
        const snapPoint = findSnapPoint(coords.canvasX, coords.canvasY);

        if (snapPoint) {
          const canvasRect = canvas.getBoundingClientRect();

          const snapScreenX =
            canvasRect.left + (snapPoint.x / canvas.width) * canvasRect.width;
          const snapScreenY =
            canvasRect.top + (snapPoint.y / canvas.height) * canvasRect.height;

          snapIndicator.style.left = snapScreenX + "px";
          snapIndicator.style.top = snapScreenY + "px";
          snapIndicator.style.display = "block";
        } else {
          snapIndicator.style.display = "none";
        }
      });

      canvas.addEventListener("mouseleave", function () {
        snapIndicator.style.display = "none";
      });

      function eliminarSegmento(index) {
        const color = colors[index % colors.length];
        delete pointPairs[color];
        redrawTodo();
        resultsDiv.innerHTML = "";

        const unit = getSelectedUnit();
        for (let i = 0; i < colorIndex; i++) {
          const col = colors[i % colors.length];
          if (pointPairs[col] && pointPairs[col].length === 2) {
            const distPx = getDistancePrecise(
              pointPairs[col][0],
              pointPairs[col][1]
            );
            const escalaPx = parseFloat(
              document.getElementById("escala_cm_por_px").value
            );
            const distancia =
              unit === "cm" ? distPx * escalaPx : distPx * escalaPx;

            const entry = document.createElement("div");
            entry.className = "result-entry";
            entry.style.borderLeftColor = col;
            entry.style.color = col;
            entry.innerHTML = `üìè Distancia [${col}]: ${formatValue(
              distPx
            )} px / ${formatValue(
              distancia
            )} ${unit} <button class='delete-button' onclick='eliminarSegmento(${i})'>‚ùå Eliminar</button>`;
            resultsDiv.appendChild(entry);
          }
        }
      }

      function getDistancePrecise(p1, p2) {
        const dx = p2.realX - p1.realX;
        const dy = p2.realY - p1.realY;
        const distance = Math.sqrt(dx * dx + dy * dy) * baseScale;
        return distance;
      }

      function drawLine(p1, p2, color) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(p1.realX * scale, p1.realY * scale);
        ctx.lineTo(p2.realX * scale, p2.realY * scale);
        ctx.stroke();

        const midX = ((p1.realX + p2.realX) / 2) * scale;
        const midY = ((p1.realY + p2.realY) / 2) * scale;
        ctx.fillStyle = color;
        ctx.font = "bold 24px sans-serif";
        ctx.fillText(colorIndex, midX - 10, midY - 15);
      }

      function redrawTodo() {
        renderPage(1);
      }

      function redrawPoints() {
        for (const [color, pair] of Object.entries(pointPairs)) {
          pair.forEach((p) => {
            const x = p.realX * scale;
            const y = p.realY * scale;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, 2 * Math.PI);
            ctx.fill();
          });
          if (pair.length === 2) drawLine(pair[0], pair[1], color);
        }

        calibrationPoints.forEach((p) => {
          const x = p.realX * scale;
          const y = p.realY * scale;
          ctx.fillStyle = "cyan";
          ctx.beginPath();
          ctx.arc(x, y, 10, 0, 2 * Math.PI);
          ctx.fill();
        });

        puntosLargoPlano.forEach((p) => {
          const x = p.realX * scale;
          const y = p.realY * scale;
          ctx.fillStyle = "gold";
          ctx.beginPath();
          ctx.arc(x, y, 12, 0, 2 * Math.PI);
          ctx.fill();
        });

        if (puntosLargoPlano.length === 2) {
          ctx.strokeStyle = "gold";
          ctx.lineWidth = 6;
          ctx.beginPath();
          ctx.moveTo(
            puntosLargoPlano[0].realX * scale,
            puntosLargoPlano[0].realY * scale
          );
          ctx.lineTo(
            puntosLargoPlano[1].realX * scale,
            puntosLargoPlano[1].realY * scale
          );
          ctx.stroke();
        }
      }

      function zoomIn() {
        scale *= 1.2;
        renderPage(1);
        updateZoomInfo();
        requestIdleCallback(() => detectEdgePointsOptimized());
      }

      function zoomOut() {
        scale /= 1.2;
        if (scale < 0.5) scale = 0.5;
        renderPage(1);
        updateZoomInfo();
        requestIdleCallback(() => detectEdgePointsOptimized());
      }

      function resetZoom() {
        scale = baseScale;
        renderPage(1);
        updateZoomInfo();
        requestIdleCallback(() => detectEdgePointsOptimized());
      }

      function updateZoomInfo() {
        const percentage = Math.round((scale / baseScale) * 350);
        zoomInfo.textContent = `Zoom: ${percentage}%`;
      }

      function toggleSnapMode() {
        snapEnabled = !snapEnabled;
        document.getElementById("snapStatus").textContent = snapEnabled
          ? "ON"
          : "OFF";
        if (!snapEnabled) {
          snapIndicator.style.display = "none";
        }
      }

      async function enableCalibration() {
        calibrating = true;
        calibrationPoints = [];
        await showModal(
          "üéØ Calibraci√≥n",
          "Haga clic en dos puntos que representen una distancia conocida en el plano"
        );
      }

      async function mostrarLargoDelPlano() {
        midiendoLargoPlano = true;
        puntosLargoPlano = [];
        await showModal(
          "üìê Medir Plano",
          "Marque dos puntos sobre el borde del recuadro negro para medir el largo real del plano"
        );
      }

      async function clearAll() {
        const confirmed = await showModal(
          "üóëÔ∏è Limpiar Todo",
          "¬øEst√° seguro de que desea eliminar todas las mediciones?",
          true
        );
        if (confirmed) {
          pointPairs = [];
          calibrationPoints = [];
          puntosLargoPlano = [];
          colorIndex = 0;
          resultsDiv.innerHTML = "";
          renderPage(1);
        }
      }
    </script>
  </body>
</html>
