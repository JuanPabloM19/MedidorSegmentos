<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Medidor de Segmentos en PDF Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <style>
      body {
        font-family: "Segoe UI", sans-serif;
        margin: 0;
        padding: 1rem;
        background: #f5f7fa;
        color: #333;
      }
      h2 {
        color: #2c3e50;
      }
      .controls {
        margin-bottom: 1rem;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
      }
      .canvas-container {
        position: relative;
        border: 2px solid #34495e;
        overflow: auto;
        max-width: 100%;
        max-height: 80vh;
        background: #ecf0f1;
      }
      canvas {
        display: block;
        touch-action: none;
        cursor: crosshair;
      }
      .results {
        margin-top: 1rem;
      }
      .result-entry {
        margin-bottom: 0.5rem;
        padding: 8px;
        background: white;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      }
      .delete-button {
        margin-left: 10px;
        padding: 4px 8px;
        font-size: 12px;
        cursor: pointer;
        background: #e74c3c;
        color: white;
        border: none;
        border-radius: 3px;
      }
      .delete-button:hover {
        background: #c0392b;
      }
      .control-group {
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .zoom-info {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 5px 10px;
        border-radius: 15px;
        font-size: 12px;
        pointer-events: none;
      }
      .snap-indicator {
        position: absolute;
        width: 20px;
        height: 20px;
        border: 2px solid #e74c3c;
        border-radius: 50%;
        pointer-events: none;
        transform: translate(-50%, -50%);
        display: none;
        background: rgba(231, 76, 60, 0.2);
        z-index: 10;
      }
      .help-text {
        margin-top: 10px;
        padding: 10px;
        background: #d5dbdb;
        border-radius: 4px;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <h2>üìè Medidor de Segmentos en Planos PDF Pro</h2>
    <div class="controls">
      <div class="control-group">
        <input type="file" accept="application/pdf" onchange="loadPDF(event)" />
      </div>
      <div class="control-group">
        <label>Escala (cm/px): 
          <input id="escala_cm_por_px" type="number" step="0.01" value="0.1" style="width: 80px;" />
        </label>
      </div>
      <div class="control-group">
        <button onclick="enableCalibration()">üéØ Calibrar</button>
        <button onclick="zoomIn()">üîç Zoom +</button>
        <button onclick="zoomOut()">üîç Zoom -</button>
        <button onclick="resetZoom()">‚Ü∫ Reset</button>
      </div>
      <div class="control-group">
        <button onclick="toggleSnapMode()">üß≤ Snap: <span id="snapStatus">ON</span></button>
        <!-- <button onclick="downloadPDF()">üì• Descargar PDF</button> -->
        <button onclick="mostrarLargoDelPlano()">üìê Medir Plano</button>
        <button onclick="clearAll()">üóëÔ∏è Limpiar Todo</button>
      </div>
    </div>
    
    <div class="canvas-container" id="canvasContainer">
      <canvas id="canvas"></canvas>
      <div class="zoom-info" id="zoomInfo">Zoom: 350%</div>
      <div class="snap-indicator" id="snapIndicator"></div>
    </div>
    
    <div class="help-text">
      üñ±Ô∏è <strong>Controles:</strong> Botones +/- = Zoom | Scroll en contenedor = Pan | Clic = Medir | Snap autom√°tico a intersecciones
    </div>
    
    <div class="results" id="results"></div>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const canvasContainer = document.getElementById("canvasContainer");
      const resultsDiv = document.getElementById("results");
      const zoomInfo = document.getElementById("zoomInfo");
      const snapIndicator = document.getElementById("snapIndicator");
      
      const colors = ["red", "blue", "green", "purple", "orange", "brown", "pink", "teal", "gray", "black"];
      let colorIndex = 0;
      let scale = 3.5;
      let baseScale = 3.5; // Escala base para c√°lculos consistentes
      let pdfDoc, currentPage;
      let pointPairs = [];
      let fileBuffer;
      let calibrating = false;
      let calibrationPoints = [];
      let midiendoLargoPlano = false;
      let puntosLargoPlano = [];
      
      let snapEnabled = true;
      let snapRadius = 20;
      let edgePoints = [];

      // Funci√≥n para obtener coordenadas correctas del mouse
      function getMouseCoordinates(e) {
        const containerRect = canvasContainer.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        
        // Coordenadas relativas al viewport
        const viewportX = e.clientX - containerRect.left;
        const viewportY = e.clientY - containerRect.top;
        
        // Coordenadas del canvas considerando scroll
        const canvasX = (viewportX + canvasContainer.scrollLeft) * (canvas.width / canvas.offsetWidth);
        const canvasY = (viewportY + canvasContainer.scrollTop) * (canvas.height / canvas.offsetHeight);
        
        return { canvasX, canvasY, viewportX, viewportY };
      }

      async function loadPDF(event) {
        const file = event.target.files[0];
        const reader = new FileReader();
        reader.onload = async function () {
          fileBuffer = reader.result;
          pdfDoc = await pdfjsLib.getDocument({ data: fileBuffer }).promise;
          await renderPage(1);
          setTimeout(detectEdgePoints, 500);
        };
        reader.readAsArrayBuffer(file);
      }

      async function renderPage(pageNum) {
        currentPage = await pdfDoc.getPage(pageNum);
        const viewport = currentPage.getViewport({ scale });
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        const renderContext = {
          canvasContext: ctx,
          viewport,
        };
        await currentPage.render(renderContext).promise;
        redrawPoints();
        updateZoomInfo();
      }

      function detectEdgePoints() {
        if (!canvas.width || !canvas.height) return;
        
        edgePoints = [];
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        for (let y = 2; y < canvas.height - 2; y += 2) {
          for (let x = 2; x < canvas.width - 2; x += 2) {
            const idx = (y * canvas.width + x) * 4;
            
            const current = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
            
            const neighbors = [
              (data[idx - 4] + data[idx - 3] + data[idx - 2]) / 3,
              (data[idx + 4] + data[idx + 5] + data[idx + 6]) / 3,
              (data[(y-1) * canvas.width * 4 + x * 4] + data[(y-1) * canvas.width * 4 + x * 4 + 1] + data[(y-1) * canvas.width * 4 + x * 4 + 2]) / 3,
              (data[(y+1) * canvas.width * 4 + x * 4] + data[(y+1) * canvas.width * 4 + x * 4 + 1] + data[(y+1) * canvas.width * 4 + x * 4 + 2]) / 3
            ];
            
            let maxDiff = 0;
            for (let neighbor of neighbors) {
              const diff = Math.abs(current - neighbor);
              if (diff > maxDiff) maxDiff = diff;
            }
            
            if (maxDiff > 40) {
              edgePoints.push({ x, y });
            }
          }
        }
        console.log(`Detectados ${edgePoints.length} puntos de borde`);
      }

      function findSnapPoint(canvasX, canvasY) {
        if (!snapEnabled || edgePoints.length === 0) return null;
        
        let closestPoint = null;
        let minDistance = snapRadius * (scale / baseScale); // Ajustar radio seg√∫n zoom
        
        for (let point of edgePoints) {
          const distance = Math.sqrt(
            Math.pow(canvasX - point.x, 2) + Math.pow(canvasY - point.y, 2)
          );
          
          if (distance < minDistance) {
            minDistance = distance;
            closestPoint = { x: point.x, y: point.y };
          }
        }
        
        return closestPoint;
      }

      canvas.addEventListener("click", function (e) {
        const coords = getMouseCoordinates(e);
        let canvasX = coords.canvasX;
        let canvasY = coords.canvasY;
        
        const snapPoint = findSnapPoint(canvasX, canvasY);
        if (snapPoint) {
          canvasX = snapPoint.x;
          canvasY = snapPoint.y;
        }
        
        // Convertir a coordenadas normalizadas (independientes del zoom)
        const realX = canvasX / scale;
        const realY = canvasY / scale;

        if (calibrating) {
          calibrationPoints.push({ realX, realY });
          ctx.fillStyle = "cyan";
          ctx.beginPath();
          ctx.arc(canvasX, canvasY, 10, 0, 2 * Math.PI);
          ctx.fill();

          if (calibrationPoints.length === 2) {
            const distanciaPx = getDistance(calibrationPoints[0], calibrationPoints[1]);
            const metros = parseFloat(prompt("¬øCu√°ntos metros hay entre estos puntos?"));
            if (!isNaN(metros) && metros > 0) {
              const cmPorPixel = (metros * 100) / distanciaPx;
              document.getElementById("escala_cm_por_px").value = cmPorPixel.toFixed(4);
              resultsDiv.innerHTML += `<div class='result-entry' style='color:cyan'>Escala calibrada: ${cmPorPixel.toFixed(4)} cm/px</div>`;
            }
            calibrating = false;
          }
          return;
        }

        if (midiendoLargoPlano) {
          puntosLargoPlano.push({ realX, realY });
          ctx.fillStyle = "gold";
          ctx.beginPath();
          ctx.arc(canvasX, canvasY, 12, 0, 2 * Math.PI);
          ctx.fill();

          if (puntosLargoPlano.length === 2) {
            const dx = puntosLargoPlano[1].realX - puntosLargoPlano[0].realX;
            const dy = puntosLargoPlano[1].realY - puntosLargoPlano[0].realY;
            const distanciaPx = Math.sqrt(dx * dx + dy * dy) * baseScale; // Usar baseScale para consistencia
            const cmReales = (distanciaPx * 32) / (canvas.width / (scale / baseScale));

            ctx.strokeStyle = "gold";
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(puntosLargoPlano[0].realX * scale, puntosLargoPlano[0].realY * scale);
            ctx.lineTo(puntosLargoPlano[1].realX * scale, puntosLargoPlano[1].realY * scale);
            ctx.stroke();

            const midX = (puntosLargoPlano[0].realX + puntosLargoPlano[1].realX) / 2 * scale;
            const midY = (puntosLargoPlano[0].realY + puntosLargoPlano[1].realY) / 2 * scale;
            ctx.fillStyle = "gold";
            ctx.font = "bold 24px sans-serif";
            ctx.fillText("Plano", midX - 20, midY - 15);

            resultsDiv.innerHTML += `<div class='result-entry' style='color:gold'>Largo real del plano (escala 1:1): ${cmReales.toFixed(2)} cm</div>`;
            midiendoLargoPlano = false;
          }
          return;
        }

        const color = colors[colorIndex % colors.length];
        if (!pointPairs[color]) pointPairs[color] = [];
        pointPairs[color].push({ realX, realY });

        const drawX = realX * scale;
        const drawY = realY * scale;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(drawX, drawY, 10, 0, 2 * Math.PI);
        ctx.fill();

        if (pointPairs[color].length === 2) {
          drawLine(pointPairs[color][0], pointPairs[color][1], color);
          const distPx = getDistance(pointPairs[color][0], pointPairs[color][1]);
          const cmPorPx = parseFloat(document.getElementById("escala_cm_por_px").value);
          const distCm = distPx * cmPorPx;

          const idx = colorIndex;
          const entry = document.createElement("div");
          entry.className = "result-entry";
          entry.style.color = color;
          entry.innerHTML = `Distancia [${color}]: ${distPx.toFixed(2)} px / ${distCm.toFixed(2)} cm <button class='delete-button' onclick='eliminarSegmento(${idx})'>Eliminar</button>`;
          resultsDiv.appendChild(entry);
          colorIndex++;
        }
      });

      canvas.addEventListener("mousemove", function (e) {
        if (!snapEnabled) {
          snapIndicator.style.display = 'none';
          return;
        }
        
        const coords = getMouseCoordinates(e);
        const snapPoint = findSnapPoint(coords.canvasX, coords.canvasY);
        
        if (snapPoint) {
          // Posicionar el indicador correctamente respecto al contenedor
          const containerRect = canvasContainer.getBoundingClientRect();
          const snapScreenX = (snapPoint.x / canvas.width) * canvas.offsetWidth - canvasContainer.scrollLeft;
          const snapScreenY = (snapPoint.y / canvas.height) * canvas.offsetHeight - canvasContainer.scrollTop;
          
          snapIndicator.style.left = (containerRect.left + snapScreenX) + 'px';
          snapIndicator.style.top = (containerRect.top + snapScreenY) + 'px';
          snapIndicator.style.display = 'block';
        } else {
          snapIndicator.style.display = 'none';
        }
      });

      function eliminarSegmento(index) {
        const color = colors[index % colors.length];
        delete pointPairs[color];
        redrawTodo();
        resultsDiv.innerHTML = "";
        for (let i = 0; i < colorIndex; i++) {
          const col = colors[i % colors.length];
          if (pointPairs[col] && pointPairs[col].length === 2) {
            const distPx = getDistance(pointPairs[col][0], pointPairs[col][1]);
            const cmPorPx = parseFloat(document.getElementById("escala_cm_por_px").value);
            const distCm = distPx * cmPorPx;
            const entry = document.createElement("div");
            entry.className = "result-entry";
            entry.style.color = col;
            entry.innerHTML = `Distancia [${col}]: ${distPx.toFixed(2)} px / ${distCm.toFixed(2)} cm <button class='delete-button' onclick='eliminarSegmento(${i})'>Eliminar</button>`;
            resultsDiv.appendChild(entry);
          }
        }
      }

      function getDistance(p1, p2) {
        const dx = p2.realX - p1.realX;
        const dy = p2.realY - p1.realY;
        return Math.sqrt(dx * dx + dy * dy) * baseScale; // Usar baseScale para medidas consistentes
      }

      function drawLine(p1, p2, color) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(p1.realX * scale, p1.realY * scale);
        ctx.lineTo(p2.realX * scale, p2.realY * scale);
        ctx.stroke();

        const midX = (p1.realX + p2.realX) / 2 * scale;
        const midY = (p1.realY + p2.realY) / 2 * scale;
        ctx.fillStyle = color;
        ctx.font = "bold 24px sans-serif";
        ctx.fillText(colorIndex, midX - 10, midY - 15);
      }

      function redrawTodo() {
        renderPage(1);
      }

      function redrawPoints() {
        for (const [color, pair] of Object.entries(pointPairs)) {
          pair.forEach((p) => {
            const x = p.realX * scale;
            const y = p.realY * scale;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, 2 * Math.PI);
            ctx.fill();
          });
          if (pair.length === 2) drawLine(pair[0], pair[1], color);
        }
        
        calibrationPoints.forEach((p) => {
          const x = p.realX * scale;
          const y = p.realY * scale;
          ctx.fillStyle = "cyan";
          ctx.beginPath();
          ctx.arc(x, y, 10, 0, 2 * Math.PI);
          ctx.fill();
        });
        
        puntosLargoPlano.forEach((p) => {
          const x = p.realX * scale;
          const y = p.realY * scale;
          ctx.fillStyle = "gold";
          ctx.beginPath();
          ctx.arc(x, y, 12, 0, 2 * Math.PI);
          ctx.fill();
        });
        
        if (puntosLargoPlano.length === 2) {
          ctx.strokeStyle = "gold";
          ctx.lineWidth = 6;
          ctx.beginPath();
          ctx.moveTo(puntosLargoPlano[0].realX * scale, puntosLargoPlano[0].realY * scale);
          ctx.lineTo(puntosLargoPlano[1].realX * scale, puntosLargoPlano[1].realY * scale);
          ctx.stroke();
        }
      }

      function zoomIn() {
        scale *= 1.2;
        renderPage(1);
        updateZoomInfo();
      }

      function zoomOut() {
        scale /= 1.2;
        if (scale < 0.5) scale = 0.5;
        renderPage(1);
        updateZoomInfo();
      }

      function resetZoom() {
        scale = baseScale;
        renderPage(1);
        updateZoomInfo();
      }

      function updateZoomInfo() {
        const percentage = Math.round((scale / baseScale) * 350);
        zoomInfo.textContent = `Zoom: ${percentage}%`;
      }

      function toggleSnapMode() {
        snapEnabled = !snapEnabled;
        document.getElementById("snapStatus").textContent = snapEnabled ? "ON" : "OFF";
        if (!snapEnabled) {
          snapIndicator.style.display = 'none';
        }
      }

      function enableCalibration() {
        calibrating = true;
        calibrationPoints = [];
        alert("Hac√© clic en dos puntos que representen una distancia conocida en el plano");
      }

      function downloadPDF() {
        if (!fileBuffer) return;
        const blob = new Blob([fileBuffer], { type: "application/pdf" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = "plano_medido.pdf";
        link.click();
      }

      function mostrarLargoDelPlano() {
        midiendoLargoPlano = true;
        puntosLargoPlano = [];
        alert("Marc√° dos puntos sobre el borde del recuadro negro para medir el largo real del plano");
      }

      function clearAll() {
        if (confirm("¬øEst√°s seguro de que quer√©s eliminar todas las mediciones?")) {
          pointPairs = [];
          calibrationPoints = [];
          puntosLargoPlano = [];
          colorIndex = 0;
          resultsDiv.innerHTML = "";
          renderPage(1);
        }
      }

      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
    </script>
  </body>
</html>