<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Medidor de Segmentos en PDF Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <style>
      body {
        font-family: "Segoe UI", sans-serif;
        margin: 0;
        padding: 1rem;
        background: #f5f7fa;
        color: #333;
      }
      h2 {
        color: #2c3e50;
      }
      .controls {
        margin-bottom: 1rem;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
      }
      .canvas-container {
        position: relative;
        border: 2px solid #34495e;
        overflow: auto;
        max-width: 100%;
        max-height: 80vh;
        background: #ecf0f1;
      }
      canvas {
        display: block;
        touch-action: none;
        cursor: crosshair;
      }
      .results {
        margin-top: 1rem;
      }
      .result-entry {
        margin-bottom: 0.5rem;
        padding: 8px;
        background: white;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      }
      .delete-button {
        margin-left: 10px;
        padding: 4px 8px;
        font-size: 12px;
        cursor: pointer;
        background: #e74c3c;
        color: white;
        border: none;
        border-radius: 3px;
      }
      .delete-button:hover {
        background: #c0392b;
      }
      .control-group {
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .zoom-info {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 5px 10px;
        border-radius: 15px;
        font-size: 12px;
        pointer-events: none;
      }
      .snap-indicator {
        position: fixed;
        width: 20px;
        height: 20px;
        border: 3px solid #ff0000;
        border-radius: 50%;
        pointer-events: none;
        transform: translate(-50%, -50%);
        display: none;
        background: rgba(255, 0, 0, 0.2);
        z-index: 9999;
        box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
      }
      .help-text {
        margin-top: 10px;
        padding: 10px;
        background: #d5dbdb;
        border-radius: 4px;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <h2>üìè Medidor de Segmentos en Planos PDF Pro</h2>
    <div class="controls">
      <div class="control-group">
        <input type="file" accept="application/pdf" onchange="loadPDF(event)" />
      </div>
      <div class="control-group">
        <label>Escala (cm/px): 
          <input id="escala_cm_por_px" type="number" step="0.00001" value="0.1" style="width: 100px;" />
        </label>
      </div>
      <div class="control-group">
        <button onclick="enableCalibration()">üéØ Calibrar</button>
        <button onclick="zoomIn()">üîç Zoom +</button>
        <button onclick="zoomOut()">üîç Zoom -</button>
        <button onclick="resetZoom()">‚Ü∫ Reset</button>
      </div>
      <div class="control-group">
        <button onclick="toggleSnapMode()">üß≤ Snap: <span id="snapStatus">ON</span></button>
        <!-- <button onclick="downloadPDF()">üì• Descargar PDF</button> -->
        <button onclick="mostrarLargoDelPlano()">üìê Medir Plano</button>
        <button onclick="clearAll()">üóëÔ∏è Limpiar Todo</button>
      </div>
    </div>
    
    <div class="canvas-container" id="canvasContainer">
      <canvas id="canvas"></canvas>
      <div class="zoom-info" id="zoomInfo">Zoom: 350%</div>
      <div class="snap-indicator" id="snapIndicator"></div>
    </div>
    
    <div class="help-text">
      üñ±Ô∏è <strong>Controles:</strong> Botones +/- = Zoom | Scroll en contenedor = Pan | Clic = Medir | Snap autom√°tico a intersecciones
    </div>
    
    <div class="results" id="results"></div>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const canvasContainer = document.getElementById("canvasContainer");
      const resultsDiv = document.getElementById("results");
      const zoomInfo = document.getElementById("zoomInfo");
      const snapIndicator = document.getElementById("snapIndicator");
      
      const colors = ["red", "blue", "green", "purple", "orange", "brown", "pink", "teal", "gray", "black"];
      let colorIndex = 0;
      let scale = 3.5;
      let baseScale = 3.5;
      let pdfDoc, currentPage;
      let pointPairs = [];
      let fileBuffer;
      let calibrating = false;
      let calibrationPoints = [];
      let midiendoLargoPlano = false;
      let puntosLargoPlano = [];
      
      let snapEnabled = true;
      let snapRadius = 30;
      let edgePoints = [];
      
      // Variables para m√°xima precisi√≥n
      let pdfNaturalScale = 1.0; // Escala natural del PDF
      let pdfViewport = null;    // Viewport original

      // Funci√≥n mejorada para obtener coordenadas de m√°xima precisi√≥n
      function getMouseCoordinates(e) {
        const containerRect = canvasContainer.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        
        // Usar getBoundingClientRect para mayor precisi√≥n
        const rect = canvas.getBoundingClientRect();
        const viewportX = e.clientX - rect.left;
        const viewportY = e.clientY - rect.top;
        
        // Coordenadas canvas con precisi√≥n sub-pixel
        const canvasX = (viewportX * canvas.width) / rect.width;
        const canvasY = (viewportY * canvas.height) / rect.height;
        
        return { 
          canvasX: Math.round(canvasX * 1000) / 1000, // Precisi√≥n a 3 decimales
          canvasY: Math.round(canvasY * 1000) / 1000,
          viewportX, 
          viewportY 
        };
      }

      async function loadPDF(event) {
        const file = event.target.files[0];
        const reader = new FileReader();
        reader.onload = async function () {
          fileBuffer = reader.result;
          pdfDoc = await pdfjsLib.getDocument({ data: fileBuffer }).promise;
          await renderPage(1);
          setTimeout(detectEdgePoints, 500);
        };
        reader.readAsArrayBuffer(file);
      }

      async function renderPage(pageNum) {
        currentPage = await pdfDoc.getPage(pageNum);
        
        // Guardar viewport original para c√°lculos precisos
        pdfViewport = currentPage.getViewport({ scale: 1.0 });
        pdfNaturalScale = scale;
        
        const viewport = currentPage.getViewport({ scale });
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        
        const renderContext = {
          canvasContext: ctx,
          viewport,
        };
        await currentPage.render(renderContext).promise;
        redrawPoints();
        updateZoomInfo();
      }

      function detectEdgePoints() {
        if (!canvas.width || !canvas.height) return;
        
        edgePoints = [];
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Algoritmo mejorado para detecci√≥n de puntos con mayor precisi√≥n
        for (let y = 3; y < canvas.height - 3; y += 1) { // Paso m√°s peque√±o para mayor precisi√≥n
          for (let x = 3; x < canvas.width - 3; x += 1) {
            const idx = (y * canvas.width + x) * 4;
            
            // An√°lisis m√°s preciso del color
            const current = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
            
            if (current < 180) { // Umbral m√°s sensible
              // Verificar patrones de intersecci√≥n con mayor precisi√≥n
              let lineCount = 0;
              let horizontalLine = false;
              let verticalLine = false;
              let diagonalLine = false;
              
              const directions = [
                [-2, 0], [2, 0], // horizontal extendido
                [0, -2], [0, 2], // vertical extendido
                [-2, -2], [2, 2], [-2, 2], [2, -2] // diagonal extendido
              ];
              
              for (let i = 0; i < directions.length; i += 2) {
                const [dx1, dy1] = directions[i];
                const [dx2, dy2] = directions[i + 1];
                
                const checkX1 = x + dx1, checkY1 = y + dy1;
                const checkX2 = x + dx2, checkY2 = y + dy2;
                
                if (checkX1 >= 0 && checkX1 < canvas.width && checkY1 >= 0 && checkY1 < canvas.height &&
                    checkX2 >= 0 && checkX2 < canvas.width && checkY2 >= 0 && checkY2 < canvas.height) {
                  
                  const idx1 = (checkY1 * canvas.width + checkX1) * 4;
                  const idx2 = (checkY2 * canvas.width + checkX2) * 4;
                  
                  const color1 = (data[idx1] + data[idx1 + 1] + data[idx1 + 2]) / 3;
                  const color2 = (data[idx2] + data[idx2 + 1] + data[idx2 + 2]) / 3;
                  
                  if (color1 < 180 && color2 < 180) {
                    if (i === 0) horizontalLine = true;      // horizontal
                    else if (i === 2) verticalLine = true;   // vertical
                    else if (i >= 4) diagonalLine = true;    // diagonal
                    lineCount++;
                  }
                }
              }
              
              // Es intersecci√≥n si hay al menos 2 tipos de l√≠neas diferentes
              if ((horizontalLine && verticalLine) || 
                  (horizontalLine && diagonalLine) || 
                  (verticalLine && diagonalLine) || 
                  lineCount >= 3) {
                edgePoints.push({ x, y });
              }
            }
          }
        }
        
        console.log(`Detectados ${edgePoints.length} puntos de intersecci√≥n con alta precisi√≥n`);
      }

      function findSnapPoint(canvasX, canvasY) {
        if (!snapEnabled || edgePoints.length === 0) return null;
        
        let closestPoint = null;
        let minDistance = snapRadius;
        
        for (let point of edgePoints) {
          // C√°lculo de distancia con mayor precisi√≥n
          const distance = Math.sqrt(
            Math.pow(canvasX - point.x, 2) + Math.pow(canvasY - point.y, 2)
          );
          
          if (distance < minDistance) {
            minDistance = distance;
            closestPoint = { 
              x: Math.round(point.x * 1000) / 1000, // Precisi√≥n sub-pixel
              y: Math.round(point.y * 1000) / 1000 
            };
          }
        }
        
        return closestPoint;
      }

      canvas.addEventListener("click", function (e) {
        const coords = getMouseCoordinates(e);
        let canvasX = coords.canvasX;
        let canvasY = coords.canvasY;
        
        const snapPoint = findSnapPoint(canvasX, canvasY);
        if (snapPoint) {
          canvasX = snapPoint.x;
          canvasY = snapPoint.y;
        }
        
        // Convertir a coordenadas normalizadas con m√°xima precisi√≥n
        const realX = canvasX / scale;
        const realY = canvasY / scale;

        if (calibrating) {
          calibrationPoints.push({ realX, realY });
          ctx.fillStyle = "cyan";
          ctx.beginPath();
          ctx.arc(canvasX, canvasY, 10, 0, 2 * Math.PI);
          ctx.fill();

          if (calibrationPoints.length === 2) {
            const distanciaPx = getDistancePrecise(calibrationPoints[0], calibrationPoints[1]);
            const metros = parseFloat(prompt("¬øCu√°ntos metros hay entre estos puntos?"));
            if (!isNaN(metros) && metros > 0) {
              // C√°lculo de escala con m√°xima precisi√≥n
              const cmPorPixel = (metros * 100) / distanciaPx;
              document.getElementById("escala_cm_por_px").value = cmPorPixel.toFixed(6); // 6 decimales
              resultsDiv.innerHTML += `<div class='result-entry' style='color:cyan'>Escala calibrada: ${cmPorPixel.toFixed(6)} cm/px (Precisi√≥n m√°xima)</div>`;
            }
            calibrating = false;
          }
          return;
        }

        if (midiendoLargoPlano) {
          puntosLargoPlano.push({ realX, realY });
          ctx.fillStyle = "gold";
          ctx.beginPath();
          ctx.arc(canvasX, canvasY, 12, 0, 2 * Math.PI);
          ctx.fill();

          if (puntosLargoPlano.length === 2) {
            const distanciaPx = getDistancePrecise(puntosLargoPlano[0], puntosLargoPlano[1]);
            // C√°lculo mejorado para largo de plano
            const cmReales = (distanciaPx * 32) / (canvas.width / (scale / baseScale));

            ctx.strokeStyle = "gold";
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(puntosLargoPlano[0].realX * scale, puntosLargoPlano[0].realY * scale);
            ctx.lineTo(puntosLargoPlano[1].realX * scale, puntosLargoPlano[1].realY * scale);
            ctx.stroke();

            const midX = (puntosLargoPlano[0].realX + puntosLargoPlano[1].realX) / 2 * scale;
            const midY = (puntosLargoPlano[0].realY + puntosLargoPlano[1].realY) / 2 * scale;
            ctx.fillStyle = "gold";
            ctx.font = "bold 24px sans-serif";
            ctx.fillText("Plano", midX - 20, midY - 15);

            resultsDiv.innerHTML += `<div class='result-entry' style='color:gold'>Largo real del plano (escala 1:1): ${cmReales.toFixed(4)} cm (Alta precisi√≥n)</div>`;
            midiendoLargoPlano = false;
          }
          return;
        }

        const color = colors[colorIndex % colors.length];
        if (!pointPairs[color]) pointPairs[color] = [];
        pointPairs[color].push({ realX, realY });

        const drawX = realX * scale;
        const drawY = realY * scale;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(drawX, drawY, 10, 0, 2 * Math.PI);
        ctx.fill();

        if (pointPairs[color].length === 2) {
          drawLine(pointPairs[color][0], pointPairs[color][1], color);
          const distPx = getDistancePrecise(pointPairs[color][0], pointPairs[color][1]);
          const cmPorPx = parseFloat(document.getElementById("escala_cm_por_px").value);
          const distCm = distPx * cmPorPx;

          const idx = colorIndex;
          const entry = document.createElement("div");
          entry.className = "result-entry";
          entry.style.color = color;
          entry.innerHTML = `Distancia [${color}]: ${distPx.toFixed(4)} px / ${distCm.toFixed(4)} cm <button class='delete-button' onclick='eliminarSegmento(${idx})'>Eliminar</button>`;
          resultsDiv.appendChild(entry);
          colorIndex++;
        }
      });

      canvas.addEventListener("mousemove", function (e) {
        if (!snapEnabled) {
          snapIndicator.style.display = 'none';
          return;
        }
        
        const coords = getMouseCoordinates(e);
        const snapPoint = findSnapPoint(coords.canvasX, coords.canvasY);
        
        if (snapPoint) {
          const canvasRect = canvas.getBoundingClientRect();
          
          const snapScreenX = canvasRect.left + (snapPoint.x / canvas.width) * canvasRect.width;
          const snapScreenY = canvasRect.top + (snapPoint.y / canvas.height) * canvasRect.height;
          
          snapIndicator.style.left = snapScreenX + 'px';
          snapIndicator.style.top = snapScreenY + 'px';
          snapIndicator.style.display = 'block';
        } else {
          snapIndicator.style.display = 'none';
        }
      });

      canvas.addEventListener("mouseleave", function() {
        snapIndicator.style.display = 'none';
      });

      function eliminarSegmento(index) {
        const color = colors[index % colors.length];
        delete pointPairs[color];
        redrawTodo();
        resultsDiv.innerHTML = "";
        for (let i = 0; i < colorIndex; i++) {
          const col = colors[i % colors.length];
          if (pointPairs[col] && pointPairs[col].length === 2) {
            const distPx = getDistancePrecise(pointPairs[col][0], pointPairs[col][1]);
            const cmPorPx = parseFloat(document.getElementById("escala_cm_por_px").value);
            const distCm = distPx * cmPorPx;
            const entry = document.createElement("div");
            entry.className = "result-entry";
            entry.style.color = col;
            entry.innerHTML = `Distancia [${col}]: ${distPx.toFixed(4)} px / ${distCm.toFixed(4)} cm <button class='delete-button' onclick='eliminarSegmento(${i})'>Eliminar</button>`;
            resultsDiv.appendChild(entry);
          }
        }
      }

      // Funci√≥n de c√°lculo de distancia con m√°xima precisi√≥n
      function getDistancePrecise(p1, p2) {
        const dx = p2.realX - p1.realX;
        const dy = p2.realY - p1.realY;
        
        // Usar c√°lculo de distancia euclidiana con m√°xima precisi√≥n
        const distance = Math.sqrt(dx * dx + dy * dy) * baseScale;
        
        // Redondear a 6 decimales para m√°xima precisi√≥n
        return Math.round(distance * 1000000) / 1000000;
      }

      // Mantener funci√≥n original para compatibilidad
      function getDistance(p1, p2) {
        return getDistancePrecise(p1, p2);
      }

      function drawLine(p1, p2, color) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(p1.realX * scale, p1.realY * scale);
        ctx.lineTo(p2.realX * scale, p2.realY * scale);
        ctx.stroke();

        const midX = (p1.realX + p2.realX) / 2 * scale;
        const midY = (p1.realY + p2.realY) / 2 * scale;
        ctx.fillStyle = color;
        ctx.font = "bold 24px sans-serif";
        ctx.fillText(colorIndex, midX - 10, midY - 15);
      }

      function redrawTodo() {
        renderPage(1);
      }

      function redrawPoints() {
        for (const [color, pair] of Object.entries(pointPairs)) {
          pair.forEach((p) => {
            const x = p.realX * scale;
            const y = p.realY * scale;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, 2 * Math.PI);
            ctx.fill();
          });
          if (pair.length === 2) drawLine(pair[0], pair[1], color);
        }
        
        calibrationPoints.forEach((p) => {
          const x = p.realX * scale;
          const y = p.realY * scale;
          ctx.fillStyle = "cyan";
          ctx.beginPath();
          ctx.arc(x, y, 10, 0, 2 * Math.PI);
          ctx.fill();
        });
        
        puntosLargoPlano.forEach((p) => {
          const x = p.realX * scale;
          const y = p.realY * scale;
          ctx.fillStyle = "gold";
          ctx.beginPath();
          ctx.arc(x, y, 12, 0, 2 * Math.PI);
          ctx.fill();
        });
        
        if (puntosLargoPlano.length === 2) {
          ctx.strokeStyle = "gold";
          ctx.lineWidth = 6;
          ctx.beginPath();
          ctx.moveTo(puntosLargoPlano[0].realX * scale, puntosLargoPlano[0].realY * scale);
          ctx.lineTo(puntosLargoPlano[1].realX * scale, puntosLargoPlano[1].realY * scale);
          ctx.stroke();
        }
      }

      function zoomIn() {
        scale *= 1.2;
        renderPage(1);
        updateZoomInfo();
        setTimeout(detectEdgePoints, 300);
      }

      function zoomOut() {
        scale /= 1.2;
        if (scale < 0.5) scale = 0.5;
        renderPage(1);
        updateZoomInfo();
        setTimeout(detectEdgePoints, 300);
      }

      function resetZoom() {
        scale = baseScale;
        renderPage(1);
        updateZoomInfo();
        setTimeout(detectEdgePoints, 300);
      }

      function updateZoomInfo() {
        const percentage = Math.round((scale / baseScale) * 350);
        zoomInfo.textContent = `Zoom: ${percentage}%`;
      }

      function toggleSnapMode() {
        snapEnabled = !snapEnabled;
        document.getElementById("snapStatus").textContent = snapEnabled ? "ON" : "OFF";
        if (!snapEnabled) {
          snapIndicator.style.display = 'none';
        }
      }

      function enableCalibration() {
        calibrating = true;
        calibrationPoints = [];
        alert("Hac√© clic en dos puntos que representen una distancia conocida en el plano");
      }

      function downloadPDF() {
        if (!fileBuffer) return;
        const blob = new Blob([fileBuffer], { type: "application/pdf" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = "plano_medido.pdf";
        link.click();
      }

      function mostrarLargoDelPlano() {
        midiendoLargoPlano = true;
        puntosLargoPlano = [];
        alert("Marc√° dos puntos sobre el borde del recuadro negro para medir el largo real del plano");
      }

      function clearAll() {
        if (confirm("¬øEst√°s seguro de que quer√©s eliminar todas las mediciones?")) {
          pointPairs = [];
          calibrationPoints = [];
          puntosLargoPlano = [];
          colorIndex = 0;
          resultsDiv.innerHTML = "";
          renderPage(1);
        }
      }

      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
    </script>
  </body>
</html>